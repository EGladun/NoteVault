---
tags:
  - Multithreading
  - Problem
---
### Описание
**Race condition** — ситуация, в которой ожидаемый порядок выполнения операций становится непредсказуемым, в результате чего страдает закладываемая логика

**Состояние гонки** (_race condition_), также **конкуренция** — ошибка проектирования многопоточной системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода. Своё название ошибка получила от похожей ошибки проектирования электронных схем (см. [_Гонки сигналов_](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%81%D1%82%D1%8F%D0%B7%D0%B0%D0%BD%D0%B8%D0%B5_%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB%D0%BE%D0%B2)).

Термин _состояние гонки_ относится к инженерному жаргону и появился вследствие неаккуратного дословного перевода английского эквивалента. В более строгой академической среде принято использовать термин **неопределённость параллелизма**.

Состояние гонки — «плавающая» ошибка, проявляющаяся в случайные моменты времени и «пропадающая» при попытке её локализовать.
### Примеры
```swift
// 1
var value: Int = 0
let serialQueue = DispatchQueue(label: "ru.anyname.serial-queue")
// 2
func increment() { value += 1 }
// 3
serialQueue.async {    
	// 4    
	sleep(5)    
	increment()
}
// 5
print(value)
// 6
value = 10
// 7
serialQueue.sync {    
	increment()
}
// 8
print(value)
```
1. Создаем свойство `value` и последовательную очередь `serialQueue`
2. Описываем функцию инкрементирования `value`
3. Планируем задачу и сразу же возвращаем управление вызывающей очереди
4. Имитируем продолжительную работу усыпляя поток и тут же вызываем функцию `increment`
5. Выводим в консоль значение переменной `value`, получаем 0 и вот тут начинается самое интересное. Для полноты картины представьте, что начиная с этого пункта и до конца сниппета, код находится в другой части приложения, а зависимости (value, serialQueue) переданы через DI. То есть вы и понятия не имеете, что через 5 секунд `value` будет инкрементирован. Мы получаем в консоли значение 0 и для нас это своего рода source of truth.
6. Передаем в переменную `value` новое значение
7. На этот раз инкрементируем синхронно
8. Снова выводим значение `value` в консоль. Ожидаем получить 11, но получаем 12.

Чтобы решить проблему в этом примере, достаточно синхронизировать вызывающую [[Dispatch Queue|очередь]] и `serialQueue`, тогда мы сможем гарантировать работу с актуальным значением value:
```swift
var value: Int = 0
let serialQueue = DispatchQueue(label: "ru.anyname.serial-queue")

func increment() { value += 1 }
// Вот тут
serialQueue.sync {    
	sleep(5)    
	increment()
}

print(value)

value = 10

serialQueue.sync {    
	increment()
}

print(value)
```
Race condition является одной из самых сложно отлавливаемых (но не самых страшных) проблем. Проще избежать, чем исправлять, поэтому к проектированию многопоточного кода нужно подходить ответственно и с умом.