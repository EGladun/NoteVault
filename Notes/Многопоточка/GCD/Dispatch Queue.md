---
tags:
  - GCD
  - Multithreading
  - Queue
---
Очереди делятся на 2 типа:
- **Serial (последовательная)** — когда задача (замыкание), которая находится на вершине очереди, “вытягивается” iOS и работает до тех пор, пока не закончится, затем вытягивается следующий элемент из очереди и т.д.
- **Concurrent (параллельные)** — когда система “вытягивает” замыкание, находящееся на вершине очереди, и запускает ее на выполнение в определенном потоке. Если у системы еще есть ресурсы, то она берет следующий элемент из очереди и запускает его на выполнение в другом потоке в то время, пока первая функция еще работает. И так система может вытянуть целый ряд функций.

Для того, чтобы создать очередь, нам необходимо создать объект типа `DispatchQueue`.
``` swift
convenience init(label: String, 
				 qos: DispatchQoS = .unspecified, 
				 attributes: DispatchQueue.Attributes = [],
				 autoreleaseFrequency: DispatchQueue.AutoreleaseFrequency = .inherit, 
				 target: DispatchQueue? = nil)
```
- **label** – строка, необходимая для идентификации очереди. Так как приложение, библиотеки и фреймворки могут создавать свои собственные очереди, необходимо придерживаться DNS стиля, например `ru.denisegaluev.queue` для достижения уникальности. Так же идентификатор поможет определить очередь во время отладки.
- **qos** – необходим для приоритизации очереди по [[Quality Of Service(QoS)]].
- **attributes** – атрибуты, определяющие поведение очереди. Такими атрибутами могут быть `.concurrent`, определяющий очередь, как параллельную или `.initiallyInactive`, определяющий очередь неактивной, до тех пор, пока не будет вызван метод очереди `activate()`.
- **autoreleaseFrequency** – частота автоосвобождения объебктов очереди. (см. [DispatchQueue.AutoreleaseFrequency](https://developer.apple.com/documentation/dispatch/dispatchqueue/autoreleasefrequency))
- **target** – таргет очереди, в которой будут выполняться задачи. Таким образом возможно перенаправить выполнение задач на очередь, переданную в данный аргумент.

Создание serial очереди:
``` swift
let serialQueue = DispatchQueue(label: "ru.anyname.serial-queue")
```
Для создания последовательной очереди достаточно передать в инициализатор label (идентификатор очереди). Таким образом очередь последовательная by default. Для того, чтобы создать параллельную очередь, необходимо передать соответствующий атрибут в аргумент инициализатора `attributes`:
``` swift
let concurrentQueue = DispatchQueue(label: "ru.denisegaluev.concurrent-queue", attributes: .concurrent)
```
Помимо создания собственных очередей, мы можем получить доступ к queue из глобального пула системных очередей. Данный пул содержит очереди уже созданные и используемые системой. Для использования такой очереди необходимо вызвать статическую метод `global()`.
В качестве единственного аргумента метод `global()` требует передать уже знакомый нам [[Quality Of Service(QoS)]]. Таким образом мы можем использовать очередь с учетом приоритета текущей задачи.

Помимо глобальных очередей, GCD дает возможность обратиться к главной очереди main. Рассмотрим пример обращения к системным очередям:
```swift
// DispatchQueue.global вернет системную concurrent очередь с приоритетом default.
let globalQueue = DispatchQueue.global()

// DispatchQueue.main вернет главную очередь.
let mainQueue = DispatchQueue.main
```
### Методы работы
#### Sync
**sync** — синхронное выполнение по отношению к текущей очереди — синхронизированный вызов будет блокироваться, другими словами, вызов метода sync завершится, когда его замыкание завершится (полезно, когда вам нужно дождаться завершения замыкания).
`queue.sync {…}` — помещаем задачу в очередь и ждем выполнения (очередь заблокирована и ждет выполнения задачи).

Представим, что у нас есть 7 задач, которые нам необходимо выполнить последовательно. Все выполняемые задачи by default будут выполнятся в главном потоке, а если точнее на главной очереди:
![[Pasted image 20250201001845.png]]
Каждая задача дожидается своей очереди в порядке их вызова, так как главная очередь является последовательной.
#### Async
**async** — асинхронное выполнение по отношению к текущей очереди — добавит замыкание в очередь и завершится, чтобы продолжить выполнение.
`queue.async {…}` — помещаем задачу в очередь, не ждем выполнения (очередь не блокируется, продолжает выполнение).
В том же примере с семью задачами, одну из задач запустим асинхронно:
![[Pasted image 20250201002015.png]]
Задача `task3` все так же выполняется на очереди `serialQueue`, но при этом main не дожидается ее выполнения и продолжает свою работу асинхронно. В этом и заключется суть метода async, вызывающая очередь (в нашем случае main) не будет ожидать выполнения задач на выполняющей очереди (в нашем случае serialQueue), а сразу же приступит к выполнения стоящих в очереди задач.


#### Dispatch Work Item
Фреймворк Dispatch позволяет ставить в очередь на выполнение не только замыкания, но и объекты типа [[DispatchWorkItem]].


- [[DispatchGroup]] — мониторим выполнение набора задач (полезно когда нужно отобразить несколько результатов запросов).
- [[Semaphore|DispatchSemaphore]] — ограничиваем доступ к ресурсу.
- [[Dispatch Barrier]] – механизм синхронизации задач в очереди
- DispatchSources — слушаем и реагируем на системные события.